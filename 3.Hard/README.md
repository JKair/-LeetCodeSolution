- Hard

1. Merge Intervals：
这个只是区间合并而已，不是太难，先排好序，然后只要前一个元素的结尾大于后一个元素的结尾，那就可以比对一下结尾是谁大，因为存在包含情况，所以核心就是比对结尾了。比如存在这种情况:[1,5] [2,4]，注意细节处理就可以AC了

1. Insert Interval:
这道题其实本身也不难的，只要找出需要处理的区间就好了，然后一开始懒惰，没有多加思考，以为O(n)肯定不会超时，结果还是超了，郁闷至极，以为是出现在apppend上，结果去除了各种排序。还是不行，到最后，直接砍掉不需要循环的地方，AC 

1. Longest Consecutive Sequence :
这道题的要求是时间复杂度为O(n)，所以排序完全不用想了，想了好多方法没解决，后来参考了discuss里面很多人的解法，然后知道解决方法，我的解法是首先去重，然后用另外一个set()来记录是否已经查找过，每次拿一个数出来，然后验证是否存在于num中，如果存在则记录，并且长度加一，如果不存在那么循环终止，下个数开始遍历。

1. Candy:
这道题最主要是处理递减数列的问题，我辗转了多种方法，都没办法解决，后来发现贪心是可以解决的，但是问题思路太复杂，整理起来真的不容易，于是我发现了一种算法，就是当递减数列的时候，每个小朋友要发的糖果，其实取决于开始递减的那个人，例如 1 6 5 3 2 1，当我遍历到第二个小朋友的时候，是应该给2个糖果的，第三个是应该给一个的，但是遍历到第四个的时候，问题出现了，第二个小朋友应该是要多给一个的，第三个也要多给一个的，于是就出现了一种解法，我们用一个length去记录递减数列的长度，当这个递减数列的长度超过了递减数列开始的时候的糖果树，即递减的长度超过第二个小朋友手里的糖果数，那么则需要多给第二个小朋友一个糖果，同时，要加上这个递减数列的长度，即每个人要多给一个糖果。递增数列是比较好解决的，不赘述。