- Hard

1. Merge Intervals：
这个只是区间合并而已，不是太难，先排好序，然后只要前一个元素的结尾大于后一个元素的结尾，那就可以比对一下结尾是谁大，因为存在包含情况，所以核心就是比对结尾了。比如存在这种情况:[1,5] [2,4]，注意细节处理就可以AC了

1. Insert Interval:
这道题其实本身也不难的，只要找出需要处理的区间就好了，然后一开始懒惰，没有多加思考，以为O(n)肯定不会超时，结果还是超了，郁闷至极，以为是出现在apppend上，结果去除了各种排序。还是不行，到最后，直接砍掉不需要循环的地方，AC 

1. Longest Consecutive Sequence :
这道题的要求是时间复杂度为O(n)，所以排序完全不用想了，想了好多方法没解决，后来参考了discuss里面很多人的解法，然后知道解决方法，我的解法是首先去重，然后用另外一个set()来记录是否已经查找过，每次拿一个数出来，然后验证是否存在于num中，如果存在则记录，并且长度加一，如果不存在那么循环终止，下个数开始遍历。

1. Candy:
这道题最主要是处理递减数列的问题，我辗转了多种方法，都没办法解决，后来发现贪心是可以解决的，但是问题思路太复杂，整理起来真的不容易，于是我发现了一种算法，就是当递减数列的时候，每个小朋友要发的糖果，其实取决于开始递减的那个人，例如 1 6 5 3 2 1，当我遍历到第二个小朋友的时候，是应该给2个糖果的，第三个是应该给一个的，但是遍历到第四个的时候，问题出现了，第二个小朋友应该是要多给一个的，第三个也要多给一个的，于是就出现了一种解法，我们用一个length去记录递减数列的长度，当这个递减数列的长度超过了递减数列开始的时候的糖果树，即递减的长度超过第二个小朋友手里的糖果数，那么则需要多给第二个小朋友一个糖果，同时，要加上这个递减数列的长度，即每个人要多给一个糖果。递增数列是比较好解决的，不赘述。

1. Find Minimum in Rotated Sorted Array II：
解法很多，O(n)的不讲了，最主要是O(lgn)，其实我自己也没想出来，究竟怎么做好，于是参考了标准答案，标准答案的提示就是考虑多一种情况，就是L<=M<=R的情况，但是L是不可能<R的，所以其实只存在一种L=M=R的情况。

1. Maximum Gap：
想了好久没什么太好的解决方法，不管我怎么想，时间复杂度始终会超过O(n)，于是上网搜了别人的解决方法，这里使用的是木桶排序，就是所谓的箱排序，根据鸽巢原理能算出最大值和最小值的差肯定不小于rang=(Max-Min)/(N-1)，然后借此我们可以算出每个数应该放进哪个桶(Num-Min)/rang，维护这个桶的最值。相同的桶内，差值不会超过rang-1，所以同一个桶内不可能会存在最大差值。对于每个桶的最大值和最小值，q.max-p.min可能会成为候选值，于是我们可以遍历得出。