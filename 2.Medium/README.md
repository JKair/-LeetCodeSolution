- Medium

1. Add Two Numbers:
两个数相加，其实这道题就是一个大数相加问题而已，大一已经写过好几次的了，不过之前是字符串处理，现在变成树了，太久没写C++，有点不熟，浪费了点时间，不过解决起来的思路其实不难，就是我们小学所做的那种思路就可以解决此问题

1. Binary Tree Zigzag Level Order Traversal：
这个其实就是[Maximum Depth of Binary Tree](https://github.com/JKair/LeetCodeSolution/blob/master/1.Easy/Maximum%20Depth%20of%20Binary%20Tree.cpp) 的变形来的，一开始脑筋没转过来，一直想怎么让深度为双数的倒转过来。其实只要全部数据遍历完毕在用vector来倒转就好了- -。哎，越简单越是想不到。我的错

1. Find Peak Element:
这个只是要返回最大值的下标而已，很简单，只要排序然后查找顺序就好。

1. First Missing Positive:
我没有想到很好的方法，先写着一种比较垃圾的。

1. Jump Game:
一开始不知道是什么意思，后来才理解了，原来只是一步一步走下去，没跨过一个下标就减一，但是每个下标又有新步数，最后看能不能走到最后。解题思路很简单，每一次都拿到最大步数，如果能走到最后return true，不能走到最后，就是在中途步数为0了就再见。

1. Linked List Cycle:
英语果然是硬伤啊，它要我们判断一下有没有环路，很简单的，就是直接两个指针，一个跑得快一个跑得慢，如果有环路的话，快的那个肯定会跑回来找到慢的那个的，不需要额外的记录了

1. Maximum Subarray:
一开始我是直接穷举记录的，超空间了。第二次穷举但是不记录，超时了，原因是我使用了两次循环，O(n^2)超时超成狗，然后就换成现在这种思路，后来我发现，其实你每次加加加加，如果加完之后小于0了，或者变小了，那就证明没有之前那个好，那我只要两个变量，一个始终记录最好的情况，另外一个一直往前加就好了，但是有一个情况，如果加完这次，小于0了，那证明这次加是坏情况，前面的全部舍弃了，再从下一个数开始往后加，如此，题解

1. Path SumII：
这道题是path sum的变形，要记录路径，所以思路换一下，不改变节点的值了，改变sum的值

1. pow(x,n):
快速幂AC

1. Reverse Words in a String:
倒转字符串，很简单，就是只要split处理，然后要注意的一个细节就是，要还给人家一个空格，而且注意，因为存在两个单词之间有五千万个空格这种坑爹的情况，所以如果切割之后为""切勿加上空格。

1. Search Insert Position:
这道题的意思是给你一个数，你找一下在哪里插入，很简单，最简单就是把数加入数组，然后排个序，然后看一下下标就好了。另外也可以使用二分法，节省时间

1. Sort Colors:
数字代表颜色，然后小的放在前面，大的放在后面，解法很多，最常规的思路就是记录个数还有排序了。我使用的是另外一种，有点类似快排的思想，以1为基准，比1小的滚去左边，比1大的，滚去右边，完毕。

1. Spiral Matrix:
我的解法只是纯粹的事件模拟而已，没技术含量，晚点再找一些更有技术含量的解法吧。

1. Swap Nodes in Pairs:
一开始我就弄错题意啊，悲剧啊！后来才弄清楚了，原来只是相邻交换而已。很容易，C++直接AC。

1.Repeated DNA Sequences:
一波三折啊，一看到题目就想到要以长度为10的字符串开始遍历了，第一次用list来存储，用count来找重，结果超内存，于是改进，用数字来记录，使其有一个特征码，结果超时，于是改用字典来记录，AC

1.Max Points on a Line:
这个可以根据斜率来做，还是遍历，没什么难度，不过切记，一定要浮点数当下标啊，天啊，被这个坑惨了`float((j.y - i.y))/(j.x - i.x)`

1.Find Minimum in Rotated Sorted Array:
二分法

1.Binary Tree Preorder Traversal：
题目要讲递归改装成迭代，好吧，改好了

1. Gas Station:
题目的意思是要找到一个站点，可以循环走一次的，一开始想到的是暴力破解，O(N^2)这样的解法没意思，不需要多做考虑，效率过慢，于是重新想象规划了一种新的。假设我们从i站点到p站点，是没办法完成这段旅程的，那么我们真的需要从i+1站点重新遍历吗？答案肯定是否定的，因为既然`i -> p < 0`了，那么可以说明一点，就是 `i -> p-1 < 0` ，所以我们完全没必要重新从i+1开始，而我们应该是从p+1重新开始计算，于是我们去除了很多次的循环，再要解决一个问题，就是汽油的问题，我到底能不能真的完成一圈的旅程呢？有一个充分必要条件，就是无论你的起点到底在哪里，必然要计算这整段旅程是否满足条件的，所以我们遍历一次就可以直接算出结果了，所以优化之后时间复杂度为O(n)